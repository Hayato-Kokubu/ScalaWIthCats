Monad

コンストラクタ と flatmap を持つもの


functor は monad である
例: Option, list , future

for comprehensions が使える

Scala標準では、flatMap を含むクラスがない

monad は、一連の処理の計算のための機能である

一連の処理のそれぞれで、続けるかどうかを選べる


for式 と flatMap, map を復習したいな・・・


list では、 flatMap は順列組み合わせをつくる


4.1.1 def of Monad

pure: A => F[A]
flatMap: (F[A], A => F[B]) => F[B] を持つ

Scalaz, Haskell ではそれぞれ
pure    - point - return
flatMap - bind  - >>=    としている

pure: constructer を抽象化している
      値からmonadで包まれた値をつくる

Monad則

・Left identity  // 左単位元
∀ a: A, ∀ func: A => F[B] [ pure(a).flatMap(func) == func(a) ( ∈ F[B])]
// flatMap(pure(a), func) == func(a)


・Right identity // 右単位元
∀ m: F[A],  [ m.flatMap(pure) == m ( ∈ F[B])]
// flatMap(fa, pure) == fa

・Associativity  // 推移率
∀ m: F[A], ∀ f: A => F[B] , ∀ g: B => F[C]
  [ m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g)) ( ∈ F[C])]
// flatMap( flatMap(fa, f), g) == flatmap(fa, {x => flatMap(f(x), g)})


Monad ---------> FlatMap (flatMap を持つ)
        |
        └------> Applicative (pure を持つ) ------> Functor(map を持つ)


4.7 writer monad
log 出力のため

一連の処理を記録
log がミックスすることなくできる？
    処理 と ログは関連している

Writer :  cats.data の住人 他には、〇〇T とかのmonad transformer など
                          Validated

Writer[W, A] W:type of log
             A:type of result


実行すると、WriterT???
コードの再利用のため
WriterT[W,A]の実態は、WriterT[Id, W, A] となる (Id[Writer[W,A]] をパックしたもの)

Id モナドの復習
モナドに包まれているものを引数とする関数に
包まれていないものを渡す時に使える


bimap と mapBoth の違いは
log でres を使うことが (bimap: できない, mapBoth: できる)
res でlog を使うことが (bimap: できない, mapBoth: できる)

